javascript:(async () => { const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms)); const showToast = (message, type = "success") => { const isAutomated = typeof window !== "undefined" && Object.prototype.hasOwnProperty.call(window, "__chatgptBookmarkletPrompt"); if (isAutomated) { console.log(`[AUTOMATED] Toast: ${message} (${type})`); } const toast = document.createElement("div"); toast.textContent = message; const colors = { success: "#0f766e", error: "#dc2626", info: "#2563eb", warning: "#d97706", }; Object.assign(toast.style, { position: "fixed", bottom: "16px", right: "16px", zIndex: 9999, background: colors[type] || colors.success, color: "#fff", padding: "10px 14px", borderRadius: "6px", fontSize: "13px", boxShadow: "0 4px 12px rgba(0,0,0,0.2)", fontFamily: "system-ui, sans-serif", maxWidth: "320px", wordWrap: "break-word", opacity: isAutomated ? "0.8" : "1", }); document.body.appendChild(toast); setTimeout(() => toast.remove(), isAutomated ? 3000 : 5000); }; const API_ENDPOINT = ""; const API_KEY = ""; const EXTRA_HEADERS = {}; const sendToApi = async (payload) => { if (!API_ENDPOINT) { console.warn("API endpoint not configured; skipping forward."); return null; } try { const headers = { "Content-Type": "application/json", ...EXTRA_HEADERS, }; if (API_KEY) { headers.Authorization = `Bearer ${API_KEY}`; } const response = await fetch(API_ENDPOINT, { method: "POST", headers, body: JSON.stringify(payload), mode: "cors", credentials: "omit", }); const responseBody = await response.text(); let parsed; try { parsed = responseBody ? JSON.parse(responseBody) : null; } catch (err) { parsed = responseBody; } if (!response.ok) { const errorMessage = (parsed && parsed.error) || `API responded with status ${response.status}`; throw new Error(errorMessage); } showToast("Response forwarded to API server", "success"); return parsed; } catch (error) { console.error("Failed to forward to API", error); showToast(`API forward failed: ${error.message}`, "error"); return null; } }; const chatgptSelectors = [ 'main[id="main"]', 'main', '[data-testid="chat-page"]', '.chat-container', '#__next', 'body' ]; let ready = null; for (const selector of chatgptSelectors) { ready = document.querySelector(selector); if (ready) { console.log(`ChatGPT UI detected using selector: ${selector}`); break; } } if (!ready) { alert("ChatGPT UI not detected on this page. Please ensure you're on the ChatGPT website (chatgpt.com) and try again."); return; } const promptTextSource = typeof window !== "undefined" && Object.prototype.hasOwnProperty.call(window, "__chatgptBookmarkletPrompt") ? window.__chatgptBookmarkletPrompt : prompt("Prompt to send to ChatGPT:"); const promptMode = typeof window !== "undefined" && Object.prototype.hasOwnProperty.call(window, "__chatgptBookmarkletPromptMode") ? window.__chatgptBookmarkletPromptMode : null; const isAutomated = typeof window !== "undefined" && Object.prototype.hasOwnProperty.call(window, "__chatgptBookmarkletPrompt"); if (isAutomated) { console.log(`[AUTOMATED] Prompt received: ${promptTextSource}`); console.log(`[AUTOMATED] ChatGPT UI detected using selector: ${ready ? 'found' : 'not found'}`); } if (typeof window !== "undefined" && Object.prototype.hasOwnProperty.call(window, "__chatgptBookmarkletPrompt")) { delete window.__chatgptBookmarkletPrompt; } if (typeof window !== "undefined" && Object.prototype.hasOwnProperty.call(window, "__chatgptBookmarkletPromptMode")) { delete window.__chatgptBookmarkletPromptMode; } const promptText = promptTextSource !== null && promptTextSource !== undefined ? String(promptTextSource) : ""; if (!promptText) { if (isAutomated) { console.log("[AUTOMATED] No prompt text provided, exiting"); } return; } showToast("Sending prompt to ChatGPT...", "info"); const waitForComposer = async () => { for (let i = 0; i < 40; i += 1) { const selectors = [ 'div[contenteditable="true"].ProseMirror#prompt-textarea', 'div[contenteditable="true"].ProseMirror', 'textarea[name="prompt-textarea"]', 'div[contenteditable="true"]', 'textarea[placeholder*="Ask"]', 'textarea[data-virtualkeyboard="true"]' ]; for (const selector of selectors) { const node = document.querySelector(selector); if (node) { console.log(`Composer found using selector: ${selector}`); return node; } } await sleep(250); } return null; }; const composer = await waitForComposer(); if (!composer) { if (isAutomated) { console.log("[AUTOMATED] ERROR: Could not locate the ChatGPT composer"); throw new Error("Could not locate the ChatGPT composer. Try refreshing the page."); } alert( "Could not locate the ChatGPT composer. Try refreshing the page." ); return; } if (isAutomated) { console.log("[AUTOMATED] Composer found, inserting prompt"); } composer.focus(); if (promptMode && (promptMode === "search" || promptMode === "study")) { const modeCommand = promptMode === "search" ? "/sear" : "/stu"; if (isAutomated) { console.log(`[AUTOMATED] Applying prompt mode: ${promptMode} (typing: ${modeCommand})`); } try { const range = document.createRange(); range.selectNodeContents(composer); range.deleteContents(); const selection = window.getSelection(); selection.removeAllRanges(); selection.addRange(range); document.execCommand("insertText", false, modeCommand); } catch (error) { composer.innerHTML = ""; composer.textContent = modeCommand; const inputEvent = new InputEvent("input", { data: modeCommand, bubbles: true, composed: true, }); composer.dispatchEvent(inputEvent); } await sleep(200); const enterEvent = new KeyboardEvent("keydown", { key: "Enter", code: "Enter", keyCode: 13, which: 13, bubbles: true, composed: true, }); composer.dispatchEvent(enterEvent); await sleep(500); } const markdownInstruction = "IMPORTANT: You MUST respond ONLY with raw markdown script/text (the source code, not the rendered version). Return the actual markdown syntax with all the markdown characters like #, *, **, -, etc. Do NOT return interpreted/rendered markdown. Do NOT include any explanatory text, introductions, conclusions, or commentary. Do NOT say 'here is your answer' or 'here is the markdown'. Do NOT wrap the markdown in code blocks or backticks. Do NOT add any HTML tags or formatting outside of markdown syntax. Respond with ONLY the raw markdown source code that directly answers the question. Start immediately with the markdown source and end immediately after it. No additional text before or after the markdown script.\n\n"; const finalPromptText = markdownInstruction + promptText; try { const range = document.createRange(); range.selectNodeContents(composer); range.deleteContents(); const selection = window.getSelection(); selection.removeAllRanges(); selection.addRange(range); document.execCommand("insertText", false, finalPromptText); } catch (error) { composer.innerHTML = ""; composer.textContent = finalPromptText; const inputEvent = new InputEvent("input", { data: finalPromptText, bubbles: true, composed: true, }); composer.dispatchEvent(inputEvent); } await sleep(150); const sendButtonSelectors = [ 'button[data-testid="composer-send-button"]', 'button[data-testid="send-button"]', 'button[aria-label*="Send"]', 'button[type="submit"]', 'button[class*="composer"]', 'button[class*="send"]', 'form button:not([type="button"])', 'button:not([type="button"])' ]; let sendButton = null; for (const selector of sendButtonSelectors) { sendButton = document.querySelector(selector); if (sendButton) { break; } } if (!sendButton) { if (isAutomated) { console.log("[AUTOMATED] ERROR: No send button found"); throw new Error("Prompt inserted, but no send button was found. Press Enter manually."); } alert( "Prompt inserted, but no send button was found. Press Enter manually." ); return; } if (isAutomated) { console.log("[AUTOMATED] Send button found, clicking"); } sendButton.click(); showToast("Prompt sent! Waiting for response...", "info"); await sleep(1000); const waitForResponseMarker = async () => { while (true) { const stopButton = document.querySelector('button[data-testid="stop-button"]'); const voiceButton = document.querySelector('button[data-testid="composer-speech-button"]'); if (voiceButton && !stopButton) { console.log("ChatGPT finished processing - voice button detected"); return voiceButton; } if (stopButton) { console.log("ChatGPT still processing - stop button detected"); await sleep(250); continue; } await sleep(250); } }; const copyButton = await waitForResponseMarker(); if (isAutomated) { console.log("[AUTOMATED] Response detected, waiting for text to load"); } showToast("Response detected! Waiting for text to load...", "info"); await sleep(2000); const cleanResponseText = (text) => { const artifacts = [ /^mdCopy code\s*/gi, /^markdownCopy code\s*/gi, /^Copy code\s*/gi, /^markdown\s*/gi, /^Copy\s*/gi, /^code\s*/gi, /\s*mdCopy code\s*$/gi, /\s*Copy code\s*$/gi, /\s*markdownCopy code\s*$/gi, /\s*Copy\s*$/gi, /\s*markdown\s*$/gi, /\s*code\s*$/gi ]; let cleanedText = text; artifacts.forEach(pattern => { cleanedText = cleanedText.replace(pattern, ''); }); return cleanedText.trim(); }; const waitForResponseText = async () => { for (let i = 0; i < 200; i += 1) { const selectors = [ ".markdown.prose", "[data-message-author-role='assistant'] .markdown", ".prose.markdown", "[data-testid='conversation-turn-3'] .markdown", ".markdown" ]; for (const selector of selectors) { const elements = document.querySelectorAll(selector); for (let j = elements.length - 1; j >= 0; j--) { const element = elements[j]; const rawText = element.textContent.trim(); if (rawText && rawText.length > 10) { const cleanedText = cleanResponseText(rawText); if (cleanedText && cleanedText.length > 5) { return cleanedText; } } } } await sleep(500); } return null; }; const responseText = await waitForResponseText(); if (!responseText) { if (isAutomated) { console.log("[AUTOMATED] ERROR: Response text not found"); throw new Error("Response text not found after waiting"); } showToast("Response text not found after waiting", "warning"); return; } if (isAutomated) { console.log(`[AUTOMATED] Response text found (${responseText.length} characters)`); } if ( responseText && !responseText.includes("window.__oai_") && !responseText.includes("async()=>{") && !responseText.includes("const sleep=") ) { const responsePayload = { prompt: promptText, response: responseText, timestamp: new Date().toISOString(), url: window.location.href, }; await sendToApi(responsePayload); const timestamp = new Date().toISOString().replace(/[:.]/g, "-"); const filename = `chatgpt-response-${timestamp}.json`; const jsonData = JSON.stringify(responsePayload, null, 2); localStorage.setItem(filename, jsonData); const existingFiles = JSON.parse( localStorage.getItem("chatgpt-files") || "[]" ); existingFiles.push(filename); localStorage.setItem("chatgpt-files", JSON.stringify(existingFiles)); showToast(`Response saved as ${filename}`, "success"); if (isAutomated) { console.log(`[AUTOMATED] SUCCESS: Response saved as ${filename}`); } console.log(`ChatGPT bookmarklet completed: ${filename}`); } else { showToast("No valid response text found", "warning"); } })();